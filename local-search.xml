<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深度学习：卷积神经网络</title>
    <link href="/2020/06/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/06/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p>边缘检测、Padding</p><a id="more"></a><h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="一、边缘检测"><a href="#一、边缘检测" class="headerlink" title="一、边缘检测"></a>一、边缘检测</h2><p>使用以3×3矩阵表示的滤波器对一幅6×6图像进行滤波（其中3×3的矩阵被称为滤波器，也称为核）最终得到另一幅4×4的图像，其中的滤波器可以看做一个垂直边缘检测器，这个运算过程就是卷积运算。</p><p><img src="/img/deeplearning/deeplearningch1-1.jpg" srcset="/img/loading.gif" alt=""></p><p>如下图所示，将较大的正值看做像素颜色更浅，将较小的负值看做像素颜色更深，可以得到矩阵的图像表示，直观地体现了这个滤波器可以完成垂直边缘检测。对于原图而言，亮度高的像素分布在图片左侧，同样对于滤波器而言，像素深度从左到右依次递增，因此卷积运算的结果可以表示原图中间存在垂直边界。</p><p>对原图进行这样的卷积运算后可以得到一幅明显的表示中间分界的图像，这个图像中间像素颜色较浅而两侧颜色较深，表示原图中对应着一个由明到暗的过渡，同时结果的分界区域较宽，这是因为原图的尺寸太小，当原图的尺寸较大时可以得到一个更合理更明显的分界。</p><p><img src="/img/deeplearning/deeplearningch1-2.jpg" srcset="/img/loading.gif" alt=""></p><p>因此卷积运算可以用来提取特征。</p><p>当原图的灰度变化与上面的例子刚好相反时，仍然使用同样的滤波器进行卷积，将会得到上述结果取负，一个中间像素颜色较深而两侧颜色较浅的结果，这表示原图中对应着一个由暗到明的过渡。</p><p>因此这个滤波器确实可以用于区分不同的明暗过渡。</p><p><img src="/img/deeplearning/deeplearningch1-3.jpg" srcset="/img/loading.gif" alt=""></p><p>相似地，可以得到用于水平边缘检测的滤波器。</p><p><img src="/img/deeplearning/deeplearningch1-4.jpg" srcset="/img/loading.gif" alt=""></p><p>除此之外，还有许多种组合的滤波器。如下图所示，Sobel滤波器，它的优点在于增加了中间一行元素的权重，这使结果的鲁棒性更高；Scharr滤波器，。</p><p>当真正想要对图像进行边缘检测时，不一定要用上述的某一种滤波器，而是可以随意选择矩阵中的9个数字，将它们作为9个参数，并且使用反向传播算法理解这9个参数，得到具有良好边缘检测效果的滤波器。</p><p><img src="/img/deeplearning/deeplearningch1-5.jpg" srcset="/img/loading.gif" alt=""></p><p>将矩阵的所有数字设置成参数，在进行卷积运算之后，通过数据反馈，让神经网络自动学习，可以获得具有良好效果的滤波器。</p><p>##二、Padding-填充</p><p>当将一个n×n的原图与f×f的滤波器进行卷积运算后，得到的图像为(n-f+1)×(n-f+1)。这样的方式存在缺点，首先每进行一次卷积运算，得到的图像就会缩小，其次在角落边缘的像素只被用于计算一次，而在图像中间的像素点因为在多个f×f的交叠处，则能被使用多次，因此在边缘的像素在输出中被较少地采用，意味着图像边缘的许多信息被丢弃。</p><p>需要解决的问题：</p><ol><li>输出缩小</li><li>图像边缘信息丢失</li></ol><p>为了解决这些问题，可以在进行卷积之前填充这幅图像。如图，将原本6×6的图像填充为8×8，再对它进行卷积可以得到6×6的输出图像，习惯上可以用0填充。</p><p>假如p是填充的数量，图中p=padding=1，即在图像周围填充一个像素点，输出图像变为(n+2p-f+1)×(n+2p-f+1)，于是原本图像最边缘的像素也多次被用于计算。</p><p>实际上可以对原图填充更多像素。</p><p><img src="/img/deeplearning/deeplearningch1-6.jpg" srcset="/img/loading.gif" alt=""></p><p>对于选择填充多少像素，一般有两种方法：</p><ol><li>Valid卷积：不填充，输出缩小</li><li>Same卷积：填充后输出大小与原输入相等，则输出大小为(n+2p-f+1)×(n+2p-f+1)，使(n+2p-f+1)=n可以求得相应的p=(f-1)/2。</li></ol><p>通常情况下f为奇数，</p><ol><li>当f为奇数时，p一直为整数，这样可使原图填充对称。</li><li>当f为奇数时，过滤器具有中心点，在计算机视觉中将更便于指出过滤器的位置。</li></ol><p><img src="/img/deeplearning/deeplearningch1-7.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>deeplearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
